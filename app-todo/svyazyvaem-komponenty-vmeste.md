# Связываем компоненты вместе

На данный момент у нас имеются все компоненты, которые нам нужны, пришло время объединять их. В этом уроке мы должны ответить на несколько вопросов: 

* Где хранить список?
* Каким образом мы добавляем новые пункты?
* Как отобразить несколько дел сразу?
* Каким образом мы их удаляем?

В этом уроке присутствует повышенная концентрация JavaScript. Я постараюсь объяснить все сложные моменты, а глубже с теорией мы познакомимся в [следующей главе](../teoriya-intensiv-po-javascript.md).

## Где хранить список? 

У нас есть два компонента: первый \(`Field.jsx`\) добавляет новые элементы, второй \(`Item.jsx`\) отображает их и имеет возможность удалить. Так как компоненты не должны знать друг о друге, быть максимально изолированными, хранить данные мы будем в ближайшем общем предке, стало быть, `TodoApp.jsx`:

{% tabs %}
{% tab title="TodoApp.jsx" %}
```jsx
export function TodoApp() {
  const [items, setItems] = useState([]);

...
```
{% endtab %}
{% endtabs %}

## Каким образом мы добавляем новые пункты?

Нам нужен способ сообщить в главный компонент \(`TodoApp`\), что произошло нажатие кнопки добавления, и что Field хочет добавить новую запись в наш список. В Реакте это делается с помощью _коллбеков_. Коллбек \(от англ. call back — "перезвони мне"\) — это функция, которая передается из родительского компонента в дочерний как параметр, которую дочерний компонент вызывает для того, чтобы сигнализировать родителю о том, что произошло какое-то действие. Давай посмотрим, как мы можем применить это в нашей ситуации.

Для начала добавим `Field` в `TodoApp`\(не забудь импортировать его\): 

{% tabs %}
{% tab title="TodoApp.jsx" %}
```jsx
import { Field } from './field';

export function TodoApp() {
  //...

  return (
    <div>
      <Field />
    </div>
  );
}
```
{% endtab %}
{% endtabs %}

Создадим функцию, которая будет коллбеком и добавим ее к пропсам `Field`:

{% tabs %}
{% tab title="TodoApp.jsx" %}
```jsx
export function TodoApp() {
  //...

  function addNewItem() {
  
  }

  return (
    <div>
      <Field onAdd={addNewItem} />
    </div>
  );
}
```
{% endtab %}
{% endtabs %}

Перейдем в `Field.jsx` и пропишем этот коллбек как обработчик нажатия кнопки:

{% tabs %}
{% tab title="Field.jsx" %}
```jsx
export function Field(props) {

  const [text, setText] = useState('');

  function onButtonClick() {
    props.onAdd(text)
  }
  
  return (
    //...
    <button onClick={onButtonClick}>
      New
    </button>
  );
}
```
{% endtab %}
{% endtabs %}

\(некоторые куски кода были пропущены для краткости\)

Что здесь происходит: 

1. При нажатии кнопки вызывается `onButtonClick`
2. `onButtonClick`  вызывает переданный "сверху" `onAdd` и передает ему как первый аргумент значение поля ввода.

Вернемся в `TodoApp.jsx` и напишем код, который добавляет элемент в список:

{% tabs %}
{% tab title="TodoApp.jsx" %}
```jsx
function addNewItem(newItem) {
  setItems([...items, newItem]);
}
```
{% endtab %}
{% endtabs %}

Это сложная конструкция, давай разберем по частям:

1. Функция `addNewItem` вызывается, когда мы нажимаем на кнопку добавления newItem — новый элемент.
2. Внутри неё мы изменяем значение `items`, теперь оно равно `[...items, newItem]`
3. `[...items, newItem]` — это способ описать массив, который состоит из всех элементов `items`, а также `newItem` .

